pragma solidity >= 0.4.24;


import "./SocialTicketNetworkAccessControl.sol";
import "openzeppelin-solidity/contracts/ownership/Ownable.sol";

contract SocialTicketNetworkBase is Ownable, SocialTicketNetworkAccessControl {

    uint public barCode;

    enum State
    {
        Generated,  // 0
        OnSale,  // 1
        Sold,     // 2
        OnSocialSale,    // 3
        SocialSold,       // 4
        Finished,    // 5
        Expired   // 6
    }

    struct Ticket {
        //uint    sku;  // Stock Keeping Unit (SKU)
        uint    barCode; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
        address payable ownerID;  // Metamask-Ethereum address of the current owner as the ticket moves through 7 stages
        address payable eventOrganizerID; // Metamask-Ethereum address of the Farmer
        string    eventName;  // Product ID potentially a combination of upc + sku
        string  ticketNotes; // Product Notes
        State   ticketState;  // Product State as represented in the enum above
        address payable lastSocialMemberID;
        address payable executerID; // Metamask-Ethereum address of the Retailer
    }

    struct TicketOwnershipHistory {
        uint barCode;
        address payable ownerID;
        uint256 ticketPrice;
    }

    mapping (uint => Ticket) public tickets;
    mapping (uint => uint256) public ticketsForSale;
    uint[] public ticketsForSaleList;
    mapping (uint => uint256) public ticketsForSocialSale;
    uint[] public ticketsForSocialSaleList;
    mapping (uint => TicketOwnershipHistory[]) public ticketsOwnershipHistory;
    mapping (address => uint[]) public ticketsByOwner;
    mapping (address => uint[]) public ticketsByOrganizer;

    event Generated(uint barCode);
    event OnSale(uint barCode);
    event Sold(uint barCode);
    event OnSocialSale(uint barCode);
    event SocialSold(uint barCode);
    event Finished(uint barCode);
    event Expired(uint barCode);

      // Define a modifer that checks to see if msg.sender == owner of the contract
    function isOwner(address _address) public view returns (bool) {
        return _address == owner();
    }

    // Define a modifer that verifies the Caller
    modifier verifyCaller (address _address) {
        require(msg.sender == _address, "SENDER IS NOT THE CALLER");
        _;
    }

    modifier notOwner(uint _barCode) {
        require(msg.sender != tickets[_barCode].ownerID, "SENDER IS ALREADY THE OWNER OF THE TICKET");
        _;
    }

     modifier paidEnough(uint _price) {
        require(msg.value >= _price, "PAID VALUE IS NOT ENOUGH");
        _;
    }

    modifier ticketOwner(uint _barCode) {
        require(tickets[_barCode].ownerID == msg.sender, "TICKET NOT OWNED BY THE ADDRESS");
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Harvested
    modifier generated(uint _barCode) {
        require(tickets[_barCode].ticketState == State.Generated, "TICKET STATE NOT GENERATED");
        _;
    }

    modifier onSale(uint _barCode) {
        require(tickets[_barCode].ticketState == State.OnSale, "TICKET STATE NOT ON SALE");
        _;
    }

    modifier sold(uint _barCode) {
        require(tickets[_barCode].ticketState == State.Sold, "TICKET STATE NOT SOLD");
        _;
    }

    modifier onSocialSale(uint _barCode) {
        require(tickets[_barCode].ticketState == State.OnSocialSale, "TICKET STATE NOT ON SOCIAL SALE");
        _;
    }

    modifier socialSold(uint _barCode) {
        require(tickets[_barCode].ticketState == State.SocialSold, "TICKET STATE NOT SOCIAL SOLD");
        _;
    }

    modifier ticketHasOwner(uint _barCode) {
        require(
            tickets[_barCode].ticketState == State.SocialSold || tickets[_barCode].ticketState == State.Sold,
            "TICKET STATE NOT SOCIAL SOLD");
        _;
    }

    modifier notFinished(uint _barCode) {
        require(tickets[_barCode].ticketState != State.Finished, "TICKET STATE IS FINISHED");
        _;
    }

    modifier notExpired(uint _barCode) {
        require(tickets[_barCode].ticketState != State.Expired, "TICKET STATE IS EXPIRED");
        _;
    }

    modifier ticketOfEventOrganizer(uint _barCode) {
        require(tickets[_barCode].eventOrganizerID == msg.sender, "TICKET IS NOT FROM EVENT ORGANIZER");
        _;
    }

    constructor() Ownable() public payable {
        barCode = 0;
    }

    function kill() public {
        if (msg.sender == owner()) {
            address payable owner = address(uint160(owner()));
            selfdestruct(owner);
        }
    }

    function generateTicket(
        string memory _eventName,
        string memory _ticketNotes
    ) public onlyEventOrganizer verifyCaller(msg.sender) {
        barCode = barCode + 1;

        require(tickets[barCode].barCode == 0, "TICKET ALREADY CREATED");

        Ticket memory tkt = Ticket(
            barCode,
            msg.sender,
            msg.sender,
            _eventName,
            _ticketNotes,
            State.Generated,
            address(0),
            address(0)
        );

        tickets[barCode] = tkt;
        insertElementInArray(barCode, ticketsByOwner[msg.sender]);
        insertElementInArray(barCode, ticketsByOrganizer[msg.sender]);
        emit Generated(barCode);
    }

    function putTicketOnSale(uint _barCode, uint _ticketPrice) public
        onlyEventOrganizer
        verifyCaller(msg.sender)
        generated(_barCode)
        ticketOwner(_barCode)
        notExpired(_barCode)
        notFinished(_barCode) {

        ticketsForSale[_barCode] = _ticketPrice;
        insertElementInArray(_barCode, ticketsForSaleList);
        tickets[_barCode].ticketState = State.OnSale;
        emit OnSale(_barCode);
    }

    function getPriceByTicketOnSale(uint _barCode) public view returns(uint256) {
        return ticketsForSale[_barCode];
    }

    function getPriceByTicketOnSocialSale(uint _barCode) public view returns(uint256) {
        return ticketsForSocialSale[_barCode];
    }

    function buyTicket(uint _barCode) public
        onlySocialMember
        verifyCaller(msg.sender)
        onSale(_barCode)
        paidEnough(ticketsForSale[_barCode])
        notExpired(_barCode)
        notFinished(_barCode) payable {

        tickets[_barCode].ownerID = msg.sender;
        tickets[_barCode].ticketState = State.Sold;

        uint256 _price = ticketsForSale[_barCode];
        ticketsOwnershipHistory[_barCode].push(TicketOwnershipHistory(_barCode, msg.sender, _price));
        removeElementFromArray(_barCode, ticketsByOwner[tickets[_barCode].eventOrganizerID]);
        insertElementInArray(_barCode, ticketsByOwner[msg.sender]);
        removeElementFromArray(_barCode, ticketsForSaleList);
        tickets[_barCode].eventOrganizerID.transfer(_price);
        uint256 amountToReturn = msg.value - _price;
        msg.sender.transfer(amountToReturn);
        delete ticketsForSale[_barCode];

        emit Sold(_barCode);
    }

    function socialPutTicketOnSale(uint _barCode, uint _ticketPrice) public
        onlySocialMember
        verifyCaller(msg.sender)
        notExpired(_barCode)
        notFinished(_barCode)
        ticketOwner(_barCode) {
            ticketsForSocialSale[_barCode] = _ticketPrice;
            insertElementInArray(_barCode, ticketsForSocialSaleList);
            tickets[_barCode].ticketState = State.OnSocialSale;
            emit OnSocialSale(_barCode);
        }

    function socialBuyTicket(uint _barCode) public
        onlySocialMember
        notOwner(_barCode)
        verifyCaller(msg.sender)
        onSocialSale(_barCode)
        paidEnough(ticketsForSocialSale[_barCode])
        notFinished(_barCode)
        notExpired(_barCode) payable {

        tickets[_barCode].lastSocialMemberID = tickets[_barCode].ownerID;
        tickets[_barCode].ownerID = msg.sender;
        tickets[_barCode].ticketState = State.SocialSold;

        uint256 _price = ticketsForSocialSale[_barCode];
        ticketsOwnershipHistory[_barCode].push(TicketOwnershipHistory(_barCode, msg.sender, _price));

        removeElementFromArray(_barCode, ticketsByOwner[tickets[_barCode].lastSocialMemberID]);
        insertElementInArray(_barCode, ticketsByOwner[msg.sender]);
        removeElementFromArray(_barCode, ticketsForSocialSaleList);
        tickets[_barCode].lastSocialMemberID.transfer(msg.value);
        uint256 amountToReturn = msg.value - _price;
        msg.sender.transfer(amountToReturn);
        delete ticketsForSocialSale[_barCode];
        emit SocialSold(_barCode);
    }

    function receiveTicket(uint _barCode)  public
        onlyEventExecutors
        ticketHasOwner(_barCode)
        verifyCaller(msg.sender)
        notExpired(_barCode) {

        tickets[_barCode].lastSocialMemberID = tickets[_barCode].ownerID;
        tickets[_barCode].ownerID = msg.sender;
        removeElementFromArray(_barCode, ticketsByOwner[tickets[_barCode].lastSocialMemberID]);
        insertElementInArray(_barCode, ticketsByOwner[msg.sender]);
        tickets[_barCode].ticketState = State.Finished;
        emit Finished(_barCode);
    }

    function expireTicket(uint _barCode) public
        onlyEventOrganizer
        notFinished(_barCode)
        ticketOfEventOrganizer(_barCode)
        verifyCaller(msg.sender) {

        removeElementFromArray(_barCode, ticketsByOwner[tickets[_barCode].ownerID]);
        removeElementFromArray(_barCode, ticketsForSaleList);
        removeElementFromArray(_barCode, ticketsForSocialSaleList);
        if (ticketsForSale[_barCode] > 0) delete ticketsForSale[_barCode];
        if (ticketsForSocialSale[_barCode] > 0) delete ticketsForSocialSale[_barCode];
        insertElementInArray(_barCode, ticketsByOwner[msg.sender]);
        tickets[_barCode].ownerID = msg.sender;
        tickets[_barCode].ticketState = State.Expired;
        emit Expired(_barCode);
    }

     function loadTicketsByOwner(address _owner)public view returns(uint[] memory) {
         return ticketsByOwner[_owner];
    }

    function loadTicketsByOrganizer(address _organizer) public view returns(uint[] memory) {
        return ticketsByOrganizer[_organizer];
    }

    function loadTicketsOnSale() public view returns(uint[] memory) {
        return ticketsForSaleList;
    }

    function loadTicketsOnSocialSale() public view returns(uint[] memory) {
        return ticketsForSocialSaleList;
    }

    function getTicketByBarCode(uint _barCode) public view returns(
        address,
        address,
        string memory,
        string memory,
        State,
        address,
        uint) {
        return (
            tickets[_barCode].ownerID,
            tickets[_barCode].eventOrganizerID,
            tickets[_barCode].eventName,
            tickets[_barCode].ticketNotes,
            tickets[_barCode].ticketState,
            tickets[_barCode].lastSocialMemberID,
            _barCode
        );
    }

    function insertElementInArray(uint element, uint[] storage array) private {
        array.push(element);
    }

    function removeElementFromArray(uint element, uint[] storage array) private returns (bool) {
        bool found = false;
        uint i = 0;
        while (i < array.length) {
            if (array[i] == element) {
                found = true;
                break;
            }
            i++;
        }
        if (found) {
            delete array[i];
            array[i] = array[array.length - 1];
            array.length = array.length - 1;
        }
        return found;
    }

}